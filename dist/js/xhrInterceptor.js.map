{
  "version": 3,
  "sources": ["../../src/xhrInterceptor.ts"],
  "sourcesContent": ["/**\n * pageWorld.ts\n * \n * This script is injected into the \"MAIN\" world of the Gmail page.\n * It has access to the same window and global objects as Gmail's own scripts.\n * \n * Purpose:\n * Intercept XMLHttpRequest to capture real-time unread count updates from Gmail's\n * internal API responses (specifically /sync/ and /mail/u/0/).\n */\n\n// Define the shape of the data we want to extract\ninterface UnreadUpdate {\n    label: string;\n    count: number;\n}\n\n// Helper to dispatch events back to the content script (isolated world)\nfunction dispatchUnreadUpdate(updates: UnreadUpdate[]) {\n    if (!updates || updates.length === 0) return;\n\n    const event = new CustomEvent('gmailTabs:unreadUpdate', {\n        detail: updates\n    });\n    document.dispatchEvent(event);\n}\n\n// Helper to parse Gmail's JSON (which often starts with )]}' or similar anti-hijacking prefixes)\nfunction parseGmailJson(text: string): any {\n    try {\n        // Remove anti-hijacking prefix if present\n        const cleanText = text.replace(/^\\)]}'\\n/, '');\n        return JSON.parse(cleanText);\n    } catch (e) {\n        // console.warn('Gmail Tabs: Failed to parse JSON', e);\n        return null;\n    }\n}\n\n// Main interception logic\nfunction interceptXHR() {\n    const XHR = XMLHttpRequest.prototype;\n    const originalOpen = XHR.open;\n    const originalSend = XHR.send;\n\n    // We don't strictly need to intercept open, but it's good for tracking URL\n    XHR.open = function (method: string, url: string | URL) {\n        // @ts-ignore\n        this._url = url.toString();\n        // @ts-ignore\n        return originalOpen.apply(this, arguments);\n    };\n\n    XHR.send = function (body) {\n        const xhr = this;\n\n        // Add load listener to capture response\n        this.addEventListener('load', function () {\n            // @ts-ignore\n            const url = xhr._url || '';\n\n            // Check if this is a relevant URL\n            // 1. /sync/ - Contains updates (new emails, read status changes)\n            // 2. /mail/u/X/ - Initial load or refresh often hits this\n            if (url.includes('/sync/') || (url.includes('/mail/u/') && !url.includes('?'))) {\n                try {\n                    const responseText = xhr.responseText;\n                    if (responseText) {\n                        processResponse(responseText);\n                    }\n                } catch (e) {\n                    console.error('Gmail Tabs: Error processing XHR response', e);\n                }\n            }\n        });\n\n        // @ts-ignore\n        return originalSend.apply(this, arguments);\n    };\n}\n\n/**\n * Process the raw response text from Gmail\n * This is the tricky part - Gmail's protocol is complex and minified.\n * We look for patterns that resemble label counts.\n */\nfunction processResponse(responseText: string) {\n    const data = parseGmailJson(responseText);\n    if (!data) return;\n\n    const updates: UnreadUpdate[] = [];\n\n    // Recursive search for label counts in the deep array structure\n    // Gmail often sends arrays like [[\"label_id\", count, ...], ...]\n    // Common System Labels: ^i (Inbox), ^t (Starred), ^s (Sent), ^r (Drafts), ^all (All Mail)\n    // Custom Labels: label-name\n\n    // We'll use a heuristic: look for arrays where:\n    // index 0 is a string (label ID)\n    // index 1 is a number (unread count) - sometimes it's index 2 or 3 depending on the specific endpoint\n\n    // NOTE: This is a simplified heuristic. Gmail's format changes. \n    // A more robust way often involves looking for specific \"u\" (unread) keys or known structures.\n    // For now, we'll try to find the specific \"counts\" array which is usually present in initial load\n    // and some sync responses.\n\n    findCounts(data, updates);\n\n    if (updates.length > 0) {\n        dispatchUnreadUpdate(updates);\n    }\n}\n\nfunction findCounts(obj: any, updates: UnreadUpdate[]) {\n    if (!obj || typeof obj !== 'object') return;\n\n    if (Array.isArray(obj)) {\n        // Heuristic for Label Count Tuple: [ \"LabelName\", UnreadCount, ... ]\n        // Usually: [ \"LabelName\", UnreadCount, TotalCount, ... ]\n        // Constraints: \n        // - Length >= 2\n        // - [0] is string (Label ID)\n        // - [1] is integer (Unread Count)\n\n        if (obj.length >= 2 && typeof obj[0] === 'string' && typeof obj[1] === 'number') {\n            const labelId = obj[0];\n            const count = obj[1];\n\n            // Filter out unlikely candidates (too short strings might be other flags, but labels can be short)\n            // System labels start with ^ usually.\n            if (isValidLabel(labelId)) {\n                updates.push({ label: labelId, count });\n            }\n        }\n\n        // Continue searching children\n        for (const item of obj) {\n            findCounts(item, updates);\n        }\n    } else {\n        // Object\n        for (const key in obj) {\n            findCounts(obj[key], updates);\n        }\n    }\n}\n\nfunction isValidLabel(label: string): boolean {\n    // Basic filter to avoid false positives\n    // Gmail system labels: ^i, ^t, ^b, ^f, ^k, ^s, ^r, ^all, ^io_im\n    // Custom labels: anything string\n\n    // Exclude obvious non-labels\n    if (!label) return false;\n    if (label.includes('http')) return false;\n    if (label.includes('gmail/att/')) return false; // Attachment paths\n    if (label.includes('/')) {\n        // Custom labels CAN have slashes (Nested/Label), but usually not starting with gmail/\n        // Let's be careful. Real labels don't usually start with a slash.\n        if (label.startsWith('/')) return false;\n    }\n    if (label.length > 80) return false; // Unlikely to be a label if extremely long\n\n    // Reject if it looks like a file path or ID string that isn't a label\n    // e.g. \"1764...\" (timestamps/IDs often appear as strings)\n    // Real labels are usually either:\n    // 1. System: ^...\n    // 2. Internal: Label_...\n    // 3. Custom: Human readable text\n\n    return true;\n}\n\n// Start interception\ninterceptXHR();\nconsole.log('Gmail Tabs: pageWorld.js loaded and intercepting XHR');\n"],
  "mappings": ";;;AAkBA,WAAS,qBAAqB,SAAyB;AACnD,QAAI,CAAC,WAAW,QAAQ,WAAW,EAAG;AAEtC,UAAM,QAAQ,IAAI,YAAY,0BAA0B;AAAA,MACpD,QAAQ;AAAA,IACZ,CAAC;AACD,aAAS,cAAc,KAAK;AAAA,EAChC;AAGA,WAAS,eAAe,MAAmB;AACvC,QAAI;AAEA,YAAM,YAAY,KAAK,QAAQ,YAAY,EAAE;AAC7C,aAAO,KAAK,MAAM,SAAS;AAAA,IAC/B,SAAS,GAAG;AAER,aAAO;AAAA,IACX;AAAA,EACJ;AAGA,WAAS,eAAe;AACpB,UAAM,MAAM,eAAe;AAC3B,UAAM,eAAe,IAAI;AACzB,UAAM,eAAe,IAAI;AAGzB,QAAI,OAAO,SAAU,QAAgB,KAAmB;AAEpD,WAAK,OAAO,IAAI,SAAS;AAEzB,aAAO,aAAa,MAAM,MAAM,SAAS;AAAA,IAC7C;AAEA,QAAI,OAAO,SAAU,MAAM;AACvB,YAAM,MAAM;AAGZ,WAAK,iBAAiB,QAAQ,WAAY;AAEtC,cAAM,MAAM,IAAI,QAAQ;AAKxB,YAAI,IAAI,SAAS,QAAQ,KAAM,IAAI,SAAS,UAAU,KAAK,CAAC,IAAI,SAAS,GAAG,GAAI;AAC5E,cAAI;AACA,kBAAM,eAAe,IAAI;AACzB,gBAAI,cAAc;AACd,8BAAgB,YAAY;AAAA,YAChC;AAAA,UACJ,SAAS,GAAG;AACR,oBAAQ,MAAM,6CAA6C,CAAC;AAAA,UAChE;AAAA,QACJ;AAAA,MACJ,CAAC;AAGD,aAAO,aAAa,MAAM,MAAM,SAAS;AAAA,IAC7C;AAAA,EACJ;AAOA,WAAS,gBAAgB,cAAsB;AAC3C,UAAM,OAAO,eAAe,YAAY;AACxC,QAAI,CAAC,KAAM;AAEX,UAAM,UAA0B,CAAC;AAgBjC,eAAW,MAAM,OAAO;AAExB,QAAI,QAAQ,SAAS,GAAG;AACpB,2BAAqB,OAAO;AAAA,IAChC;AAAA,EACJ;AAEA,WAAS,WAAW,KAAU,SAAyB;AACnD,QAAI,CAAC,OAAO,OAAO,QAAQ,SAAU;AAErC,QAAI,MAAM,QAAQ,GAAG,GAAG;AAQpB,UAAI,IAAI,UAAU,KAAK,OAAO,IAAI,CAAC,MAAM,YAAY,OAAO,IAAI,CAAC,MAAM,UAAU;AAC7E,cAAM,UAAU,IAAI,CAAC;AACrB,cAAM,QAAQ,IAAI,CAAC;AAInB,YAAI,aAAa,OAAO,GAAG;AACvB,kBAAQ,KAAK,EAAE,OAAO,SAAS,MAAM,CAAC;AAAA,QAC1C;AAAA,MACJ;AAGA,iBAAW,QAAQ,KAAK;AACpB,mBAAW,MAAM,OAAO;AAAA,MAC5B;AAAA,IACJ,OAAO;AAEH,iBAAW,OAAO,KAAK;AACnB,mBAAW,IAAI,GAAG,GAAG,OAAO;AAAA,MAChC;AAAA,IACJ;AAAA,EACJ;AAEA,WAAS,aAAa,OAAwB;AAM1C,QAAI,CAAC,MAAO,QAAO;AACnB,QAAI,MAAM,SAAS,MAAM,EAAG,QAAO;AACnC,QAAI,MAAM,SAAS,YAAY,EAAG,QAAO;AACzC,QAAI,MAAM,SAAS,GAAG,GAAG;AAGrB,UAAI,MAAM,WAAW,GAAG,EAAG,QAAO;AAAA,IACtC;AACA,QAAI,MAAM,SAAS,GAAI,QAAO;AAS9B,WAAO;AAAA,EACX;AAGA,eAAa;AACb,UAAQ,IAAI,sDAAsD;",
  "names": []
}
